#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright @ 2014 Mitchell Chu
# 

from uuid import uuid4
from driver import SessionDriverFactory
try:
    import cPickle as pickle #py2
except ImportError:
    import pickle #py3

class SessionManager(object):
    '''
    '''
    SESSION_ID = 'msid'
    DEFAULT_SESSION_LIFETIME = 1200 # seconds
    
    def __init__(self, handler):
        self.handler = handler
        self.settins = {}       # session configurations
        self._id = self.__retrieve_current_session_id()
        self._expires = self.DEFAULT_SESSION_LIFETIME

    def __init_session_object(self):
        session_id = self.handler.get_cookie(self.SESSION_ID)
        if not session_id:
            session_id = uuid4().hex
            self.handler.set_cookie(self.SESSION_ID,
                                    session_id,
                                    **self.__session_settings())
        self._id = session_id

    def __init_settings(self):
        """
        Init session relative configurations.
        all configuration settings as follow:
        settings = dict(
            cookie_secret = "00a03c657e749caa89ef650a57b53ba(&#)(",
            debug = True,
            session = {
                driver = 'memory',
                driver_settings = {},
                force_persistence = True,
            },
        )
        driver:			default enum value: memory, file, redis, memcache. 
        driver_settings:	the data driver need. settings may be the host, database, password, and so on.
				redis settings as follow:
				      driver_settings = {
				      		      host = '127.0.0.1',
						      port = '6379',
						      db = 0, # where the session data to save.
						      password = 'session_db_password', # if database has password
				 	}
        force_persistence:	default is False.
				In default, session's data exists in memory only, you must persistence it by manual.
				Generally, rewrite Tornado RequestHandler's prepare(self) and on_finish(self) to persist session data is recommended. 
        		     	when this value set to True, session data will be force to persist everytime when it has any change.
				
        """
        session_settings = self.handler.settings.get("session")
        if not session_settings: # use default
            session_settings = {}
            session_settings.update(driver='memory', driver_settings={}, force_persistence=True)
        driver = session_settings.get("driver")
        if not driver:
            raise SessionConfigurationError('driver is missed')
        self.settings = session_settings

    def get(self, key, default=None):
        '''
        Return session value with name as key.
        '''
        pass

    def set(self, key, value):
        '''
        Add/Update session value
        '''
        pass

    def delete(self, key):
        '''
        Delete session key-value pair
        '''
        pass

    def keys(self):
        '''
        Return all keys in session object
        '''
        pass

    def __setitem__(self, key, value):
        self.set(key, value)

    def __getitem__(self, key):
        val = self.get(key)
        if val: return val
        raise KeyError('%s not found' % key)

    def __contains__(self, key):
        '''
        '''
        pass

    @property
    def id(self):
        '''
        Return current session id
        '''
        if not hasattr(self, '_id'):
            self._id = self.__retrieve_current_session_id()
        return self._id

    @property
    def expires(self):
        """
        The session object lifetime on server.
        this property could not be used to cookie expires setting.
        """
        if not hasattr(self, '_expires'):
            self._expires = self.__retrieve_current_session_id()
        return self._expires

    def __generate_session_id(self):
        '''
        Generate unique session id by uuid4
        '''
        session_id = uuid4().hex
        self.handler.set_cookie(self.SESSION_ID,
                                session_id,
                                **self.__session_settings())
        return session_id

    def __session_settings(self):
        session_settings = self.settings.get('session_config', {})
        session_settings.setdefault('expires', None)
        session_settings.setdefault('expires_days', None)
        return session_settings

    def __retrieve_current_session_id(self):
        session_id = self.handler.get_cookie(self.SESSION_ID)
        if session_id:return session_id
        return self.__generate_session_id()

class SessionMixin(object):
    '''
    '''
    
    @property
    def session(self):
        '''
        '''
        return self._create_mixin(self, '__session_manager', SessionManager)

    def _create_mixin(self, context, inner_property_name, session_handler):
        if not hasattr(context, inner_property_name):
            setattr(context, inner_property_name, session_handler(context))
        return getattr(context, inner_property_name)

class SessionConfigurationError(Exception):
    pass
